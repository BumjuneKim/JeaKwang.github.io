<html lang="en">
<head>
  <meta charset="utf-8">
  <title>HTTP SPEC</title>
  <link rel="stylesheet" href="/css/reveal.css">
  <link rel="stylesheet" href="/css/theme/moon.css" id="theme">
  <link rel="stylesheet" href="/css/custome/test.css">
  <!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides"> 

      <section>
      	<h1>HTTP</h1>
      </section>

      <section >
      	<section>
          <h2>HTTP</h2>
          <h3 style="text-transform: capitalize;">Hyper Text Transfer Protocol</h3>
          <p>
          이름대로라면 하이퍼텍스트 전용 프로토콜 이지만,<br/> 실제로는 컴퓨터에서 다룰 수 있는 데이터라면<br/> 무엇이든 전송할 수 있는 프로토콜 입니다.
          </p>
        </section>
	      <section>
	          <h2>HTTP 구조 및 특징</h2>
	          <p>
	          	클라이언트/서버 아키텍처 스타일<br/>
	          	요청/응답형 (Request-Response) 프로토콜<br/>
	          	동기형 (Synchronous) 프로토콜<br/>
	            스테이트 리스
	          </p>
	      </section>
      </section >

      <section>
      	<section id="http_struct">
	      	<h2>HTTP Message</h2>
					<img src="/images/test/0.png" >
				</section>
				<section>
					<h2>Request / Response Message</h2>
						<p>
{% highlight ruby %}
GET / HTTP/1.1
Host: jeakwang.github.io
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36
Accept-Encoding: gzip, deflate, sdch
Accept-Language: ko-KR,ko;q=0.8,en-US;q=0.6,en;q=0.4
If-Modified-Since: Fri, 06 Mar 2015 00:17:18 GMT
{% endhighlight %}
						</p>
						<p>
{% highlight ruby %}
HTTP/1.1 304 Not Modified
Date: Fri, 13 Mar 2015 02:34:38 GMT
Last-Modified: Fri, 06 Mar 2015 00:17:18 GMT
Cache-Control: max-age=600
Expires: Fri, 13 Mar 2015 02:44:31 GMT
Connection: keep-alive
{% endhighlight %}
					</p>
				</section>
      </section>

			<section>
				<section data-transition="fade">
					<h2>Star-Line</h2>
				</section>
				<section data-transition="fade">
					<div class="header_detail">
							<ul>
								<li><strong>Request-Line : 요청 메시지의 첫번째줄</strong>
									<ul>
										<li>구조 : 메서드 / 요청URI / 프로토콜 버전</li>
										<li>메서드 : URI로 식별하는 서버상의 리소스에 대한 수행작업</li>
									</ul>
								</li>
								<br>
								<li><strong>Status-Line : 응답 메시지의 첫번째줄</strong>
									<ul>
										<li>구조 : 프로토콜 버전 / 스테이터스 코드 / 텍스트 구문</li>
										<li>스테이터스 코드 : 요청의 결과를 프로그램으로 처리 가능한 수치로 표현한 코드
										<li>1xx : 처리중, 2xx : 성공, 3xx : 리다이렉트, 4xx : 클라이언트 오류, 5xx : 서버 오류</li>
										</li>
									</ul>
								</li>
							</ul>
					</div>
				</section>
				<section data-transition="fade">
					<h2>header</h2>
				</section>
				<section data-transition="fade">
					<div class="header_detail">
						<h2>Host, User-Agent, Server</h2>
{% highlight ruby %}
// 요청
Host: jeakwang.github.io
User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36

// 응답
Server: WEBrick/1.3.1 (Ruby/2.1.5/2014-11-13)
{% endhighlight %}
						<p>
							<ul>
								<li>Host : 요청한 URI의 호스트명과 포트명</li>
								<li>User-Agent : 요구를 만들어 낸 사용자 에이전트(브라우저)에 대한 정보</li>
								<li>Server : 서버의 소프트웨어에 정보</li>
							</ul>
						</p>
					</div>
				</section>

				<section data-transition="fade">
					<div class="header_detail">
					<h2>Date</h2>
					<p>
						요청과 응답 메시지에서 모두 사용하며 메시지를 생성한 일시를 나타냅니다.
					</p>
					<p>
{% highlight ruby %}
Date: Wed, 11 Mar 2015 03:18:57 GMT
{% endhighlight %}
					</p>
					</div>
				</section>

				<section data-transition="fade">
					<div class="header_detail">
						<h2>Connection</h2>
						<p>
							HTTP는 연결을 매번 끊고 새로 생성하는 구조입니다. <br>
							그런이유로 요청에 대한 응답을 반활할때마다 커넥션이 끊겨서 <br>
							재연결에 많은 비용을 소비되기에 동작이 느려지는 단점이 있었습니다.
						</p>
						<p>
{% highlight ruby %}
Connection: keep-alive

// 지속 연결을 중단하고 싶은 경우
Connection: close
{% endhighlight %}
						</p>
						<p>
							HTTP 1.1에는 커넥션을 절단하지 않고 지속적인 연결을 하는 기능을 지원합니다.
						</p>
					</div>
				</section>

				<section data-transition="fade">
					<div class="header_detail">
						<h2>Cache</h2>
						<p>Cache : 서버로부터 가져온 리소스를 저장하여 재사용하는 방법입니다.</p>
						<p>
{% highlight ruby %}
Pragma: no-cache
Expires : Fri, 13 Mar 2015 02:44:31 GMT
Cache-Control: no-cache      // 캐시 사용하지 않음
Cache-Control: max-age=0;    // 캐시 재요청
Cache-Control: max-age=86400 // 현재로부터 24시간
{% endhighlight %}
						</p>
						<ul>
							<li>Pragma : 리소스를 캐시할 수 없음을 나태날 때 사용합니다.</li>
							<li>Expires : 응답의 데이터가 캐시로서의 유효기간을 나타냅니다.(절대시간)</li>
							<li>Cache-Control : 클라이언트와 서버의 캐시방법을 나타냅니다.(상대시간)</li>
						</ul>
					</div>
				</section>

				<section data-transition="fade">
					<div class="header_detail">
						<h2>조건부 요청</h2>
						<p>캐시에 오래된 리소스에 대하여 아지 유효한지 서버에게 묻는 방법입니다.</p>
						<p>
{% highlight ruby %}
If-Modified-Since: Thu, 06 Mar 2015 00:17:18 GMT
Last-Modified: Thu, 06 Mar 2015 00:17:18 GMT
{% endhighlight %}
						</p>
						<p>
							<ul>
								<li>Last-Modified : 응답 메세지로 리소스에 대한 마지막 수정 날짜를 클라이언트에게 보냅니다.</li>
								<li>If-Modified-Since : 클라이언트는 캐시에 저장된 Last-Modified의 값을 담아 보내서 서버에 있는 Last-Modified와 비교합니다. 수정되었다면 새로운 리소를 보내줍니다.</li>
							</ul>
						</p>
					</div>
				</section>

				<section data-transition="fade">
					<div class="header_detail">
						<h2>Content Negotiation</h2>
						<p>
							클라이언트와 서버가 일치하는 방식으로 여러가지 의사결정을 결정합니다.
						</p>
						<p>
{% highlight ruby %}
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Charset: EUC-KR;utf-8;q=0.7,*/8;q=0.7
Accept-Language: ko-KR,ko;q=0.8,en-US;q=0.6,en;q=0.4
Accept-Encoding: gzip, deflate, sdch
{% endhighlight %}
						</p>
						<ul>
							<li>Accept : 클라이언트가 우선적으로 처리하는 미디어타입을 지정합니다.</li>
							<li>Accept-Charset : 클라이언트가 우선적으로 처리하는 문자 인코딩방식을 지정합니다.</li>
							<li>Accept-Language : 클라이언트가 우선적으로 지원하는 언어를 지정합니다.</li>
							<li>Accept-Encoding : 클라이언트가 처리할 수 인코딩 방식을 지정합니다.
								<ul>
									<li>q= 는 미디어 타입의 우선순위를 나타냅니다.(0 ~ 1 / default 1)</li>
									<li>*/*는 모든 타입을 나타냅니다.</li>
								</ul>
							</li>
						</ul>
					</div>
				</section>

				<section data-transition="fade">
					<div class="header_detail">
						<h2>리소스 정보</h2>
						<p>
{% highlight ruby %}
Content-Type: text/html
Content-Length: 1270
{% endhighlight %}
						</p>
						<ul>
							<li>Content-Type : 리소스의 미디어 타입을 타나냅니다. 이는 클라이언트의 요청의 Accept 헤더에서 우선적으로 지원하는 포맷 양식에 따라 서버는 그에 맞는 미디어 타입을 반환합니다.</li>
							<li>Content-Length : 바디가 있는 경우 바디의 길이를 나타냅니다.</li>
						</ul>
					</div>
				</section>

				<section data-transition="fade">
					<div class="header_detail">
						<h2>Session & Cookie</h2>
						<p>
						HTTP는 '스테이트리스'한 특성을 가지고 있어서 클라이언트의 정보를 저장하지는 않지만, <br> 때로는 그 정보를 기억해야할 경우에 Session 과 Cookie를 사용할 수 있습니다.
						</p>
{% highlight ruby %}
// 응답
Set-Cookie : sessionid = ab32441213; expires=Thu, 06 Mar 2015 00:17:18 GMT;

// 요청
Cookie : sessionid = ab32441213
{% endhighlight %}
						<ul>
							<li>
								Session
								<ul>
									<li>서버가 클라이언트측에 부여한 ID</li>
									<li>클라이언트와 서버간에 통신연결이 활성화되 되었다는 의미</li>
								</ul>
							</li>							
							<li>Cookie
								<ul>
									<li>서버측에서 클라이언트 측에 상태 정보를 저장하고 추출할 수 있는 메커니즘</li>
									<li>클라이언트의 매 요청마다 웹 브라우저로부터 서버에게 전송되는 정보패킷</li>
								</ul>
							</li>						
						</ul>						
					</div>
				</section>
			</section>

			<section id="https">
				<section data-transition="fade">
					<h2>HTTPS</h2>
					<p>
						HTTP<strong>S</strong>에서 S는 Over Secure Socket Layer의 약자로 Secure라는 말을 통해서 알 수 있듯이 보안이 강화된 HTTP를 의미한다.
					</p>					
					<p>
						HTTP는 암호화되지 않은 방법으로 데이터를 전송하기 때문에<br> 서버와 클라이언트가 주고 받는 메시지의 감청이나 변조가 쉽다.
					</p>
					<p>
						<h3>이를 보완한 것이 바로 HTTPS이다.</h3>
					</p>
					
				</section>

				<section data-transition="fade">
					<h2>SSL/TLS</h2>
					<img src="/images/test/OSI.png" style="width: 700px;">
					<div class="fragment fade-in">
						<div class="box"></div>
						<div class="boxDesc">
							Session Layer에서 SSL/TLS 프로토콜을 활용하여 통신로를 암호화하고<br> 클라이언트와 서버 간에 주고받는 데이터를 보호하여,<br> 도청을 방지할 수 있습니다.
						</div>
					</div>
				</section>

				<section data-transition="fade">
					<h2>대칭키</h2>
					<p>
					암호화하기위한 일종의 비밀번호를 키(Key)라고 합니다. <br>
					대칭키는 암호화와 복호화가 동시에 가능한 키입니다.<br>
					</p>
					<img src="/images/test/2.png">
					<p class="fragment fade-in">
					암호화와 복호화를 하기 위해 상대와 키를 주고받아야 하는데,<br>
					이 과정에서 대칭키가 노출될 수 있다는 단점이 있습니다.
					</p>
				</section>

				<section data-transition="fade">
					<h2>공개키</h2>
					<p>공개키는 대칭키와는 다르게 두개의 키를 가집니다. <br>
						 A키로 암호화를 하면 B키로 복호화 할 수 있고,<br>
						 B키로 암호화하면 A키로 복호화 할 수 있는 방식입니다.
					</p>
					<img src="/images/test/3.png">
					<p class="fragment fade-in">
						공개키가 유출되어도 비공개키가 없으면 복호화 불가능 <br>						
					</p>
				</section>

				<section data-transition="fade">
					<h2>SSL의 동작방법</h2>
					<p>SSL은 암호화된 데이터를 전송하기 위해서<br> 공개키와 대칭키를 혼합해서 사용하는 방법입니다.
					</p>
					<p>
						즉, 주고 받는 실제 정보는 대칭키 방식으로 암호화하고,<br>
						암호화된 실제 정보를 복호화할 때 사용할 대칭키는<br>
						공개키로 암호화해서 클라이언트와 서버가 주고 받습니다.
					</p>
					<img src="/images/test/4.png">
				</section>

				<section data-transition="fade">
					<h2>SSL 인증</h2>
					<p style="text-align: left;">
						- 접속한 사이트의 신원을 보장하는 장치가 필요하다 <br>
						- CA(Certificate authority) : 사이트의 신원을 보장하는 제3의 인증 기관
					</p>
					<ol>
						<li class="fragment fade-in">
							클라이언트가 서버에 접속하면 서버는 클라이언트에게 인증서를 전달합니다.
							(인증서는 CA의 비밀키로 암호화한 서버의 공개키와 사이트의 정보가 담겨있습니다.)
						</li>
						<li class="fragment fade-in">
							브라우저는 CA의 공개키로 인증서를 복호화하는데 성공한다면 해당 서버가 인증기관에서 인증받았다는 것을 의미합니다.
							(브라우저는 각 CA들의 공개키를 이미 알고 있습니다.)
						</li>
					</ol>
				</section>

				<section data-transition="fade">
					<h2>SSL 통신</h2>
					<p>컴퓨터와 컴퓨터가 네트워크를 이용해서 통신을 할 때는 <br> 내부적으로 3가지 단계가 있다.
					</p>
					<ol>
						<li class="fragment fade-in">
							handshake
							<ul>
								<li style="font-size: 0.7em;">Client → Server : 랜덤데이터 + 지원 암호화방식 + 세션 아이디</li>
								<li style="font-size: 0.7em;">Server → Client : 랜덤데이터 + 지원 암호화방식 + 인증서</li>
								<li style="font-size: 0.7em;">암호화방식 결정, 랜덤데이터를 이용해 대칭키 생성, 인증키로 인증</li>
							</ul>
						</li>
						<li class="fragment fade-in">session : 서버와 클라이언트가 데이터를 주고 받는 단계</li>
						<li class="fragment fade-in">session end : 데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려주고, 대칭키 폐기</li>
					</ol>
				</section>
			</section>
    </div>
  </div>
  <script src="/js/jquery-1.11.1.min.js"></script>
  <script src="/lib/js/head.min.js"></script>
  <script src="/js/reveal.js"></script>
  <script>
  Reveal.initialize({
    controls: true,
    progress: true,    
    slideNumber: true,
    // center: false,
    width: 960,
    height: 700,
    fragments: true,
    top: 0
  });
  </script>
</body>

</html>
